#pragma config(Sensor, in5,    potientom,      sensorPotentiometer)//...breytiviðnám fyrir arminn til þess að greina staðsetningu hans
#pragma config(Motor,  port1,           rightMotor,     tmotorVex393, openLoop)//vinstri mótor
#pragma config(Motor,  port10,          leftMotor,    tmotorVex393, openLoop, reversed)//...hægri mótor
#pragma config(Motor,  port2,           armMotor,      tmotorVex269, openLoop)//...armmótor
#pragma config(Motor,  port5,           clawMotor,     tmotorVex393, openLoop)//...klómótor
#pragma config(Sensor, in2,    lineFollowerRIGHT,   sensorLineFollower)//...línulesarar hægri, miðja og vinstri
#pragma config(Sensor, in3,    lineFollowerCENTER,  sensorLineFollower)//
#pragma config(Sensor, in4,    lineFollowerLEFT,    sensorLineFollower)//
#pragma config(Sensor, dgtl11, robot_stop,     sensorTouch)//...neyðarstopphnappurinn
#pragma config(Sensor, in1,    light_sensor,   sensorReflection)//...ljósskynjarinn
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)//...vinstrikótari
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)//...hægrikótari
#pragma config(Sensor, dgtl7,  sonar_sensor,   sensorSONAR_cm)//...ómskynjari
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//...Hafa verkefni 2a(vélarmur og klær), verkefni3(ljós-/óm-skynjarar), verkefni4(línulesskynjarar) til hliðsjónar
//...og prufa.c fyrir prufukeyrslu
#define BASELIGHT 200
#define BASEDEG 2.7
int threshold = 2000;

void armUP(){
	motor[armMotor]=-127; //...lyfta upp arminn.
	while(SensorValue[potientom] <800){
		motor[armMotor]=-127;	//...lyfta upp arminn.
		wait1Msec(2000);
		} motor[armMotor]=0;
}

void armDown(){
	while(SensorValue[potientom] > 800){
			motor[armMotor]=127; //...lækka niður arminn.
			wait1Msec(2000);
			} motor[armMotor]=0;
}

void clawOpen(){
	motor[clawMotor] = -127; //...opna gripklónna.
	wait1Msec(2000);
	}

void clawClose(){
	motor[clawMotor] = 127; //...loka gripklónna.
	wait1Msec(2000);
	}

task stop_all(){//...neyðarstopp-fallið
	while(!robot_stop || vexRT[Btn5D]!=1){
	}
	stopAllTasks();
}

void stopMotors(){//...stöðva mótora
	motor[rightMotor] = 0;
	motor[leftMotor] = 0;
}

void resetEncoder(){//...endursetja kótara
	SensorValue[rightEncoder]=0;
	SensorValue[leftEncoder]=0;
}

void turn(){//...snúa við 180° (gyro er uppbyggður í fallinu)
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
  SensorType[in8] = sensorNone;
  wait1Msec(1000);
  //Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
  SensorType[in8] = sensorGyro;
  wait1Msec(2000);

  //Adjust SensorScale to correct the scaling for your gyro
  //SensorScale[in8] = 260;
  //Adjust SensorFullCount to set the "rollover" point. A value of 3600 sets the rollover point to +/-3600
  //SensorFullCount[in8] = 3600;

  //Specify the number of degrees for the robot to turn (100 degree = 10, or 900 = 90 degrees)
  int degrees10 = 1800;

  //While the absolute value of the gyro is less than the desired rotation...
  while(abs(SensorValue[in8]) < degrees10)
  {
    //...continue turning
    motor[rightMotor] = 50;
    motor[leftMotor] = -50;
  }

  //Brief brake to stop some drift
  motor[rightMotor] = -5;
  motor[leftMotor] = 5;
  wait1Msec(250);
}

task main()
{
	wait1Msec(2000);          // The program waits for 2000 milliseconds before continuing.
	startTask(stop_all);

     /* found by taking a reading on both DARK and LIGHT    */
		/* surfaces, adding them together, then dividing by 2. */
		while(true)
		{
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
			displayLCDCenteredString(0, "LEFT  CNTR  RGHT");        //  Display   |
			displayLCDPos(1,0);                                     //  Sensor    |
			displayNextLCDNumber(SensorValue(lineFollowerLEFT));    //  Readings  |
			displayLCDPos(1,6);                                     //  to LCD.   |
			displayNextLCDNumber(SensorValue(lineFollowerCENTER));  //            |
			displayLCDPos(1,12);                                    //  L  C  R   |
			displayNextLCDNumber(SensorValue(lineFollowerRIGHT));   //  x  x  x   |
			// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -+
			// RIGHT sensor sees dark:
			if(SensorValue(lineFollowerRIGHT) > threshold)
			{
				// counter-steer right:
				motor[leftMotor]  = 63;
				motor[rightMotor] = 0;
			}
			// Left sensor sees dark:
			if(SensorValue(lineFollowerLEFT) > threshold)
			{
				//counter-steer left:
				motor[leftMotor] = 0;
				motor[rightMotor] = 63;
			}

			// Left sensor sees dark:
			if(SensorValue(lineFollowerCENTER) > threshold)
			{
				//counter-steer left:
				motor[leftMotor] = 63;
				motor[rightMotor] = 63;
			}
		while(SensorValue(light_sensor) < BASELIGHT){
				while(SensorValue(sonar_sensor) < 50 || SensorValue(sonar_sensor) == -1){
					stopMotors();
					resetEncoder();
					armDown();
					clawOpen();
					wait1Msec(1000);
					motor[leftMotor] = 63;
					motor[rightMotor] = 63;
					wait1Msec(1000);
					clawClose();
					wait1Msec(500);
					armUP();
					turn();
					stopMotors();
				}
			}
		}
	}
